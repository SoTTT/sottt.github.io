---
title: 内存模型:读Memory Models (by Russ Cox)
layout: post
date: 2024-02-27
---

## 前言

在现代编程语言中，并发作为提高程序响应性和性能的一个重要手段，是一个重要的主题；一方面，现代语言提供了高级的线程设施、同步原语和并发工具，另一方面也定义了更精细的控制多线程语境下硬件并发和编译器优化的手段，即内存模型。

从应用来看，内存模型的定义比较底层，不是编写应用时常用的工具，但是了解内存模型对学习并发编程是有帮助的，硬件及软件内存模型发展的历史，也是计算机科学界不断探索并发编程的历史，了解这段历史，对于理解编程语言为何会成为现在这样以及了解并发的一些基本问题是有帮助的。

我在之前曾学习 Java 和 C++语言的内存模型，但是始终不得要领，最近有幸拜读 Go 语言项目领导者之一的*Russ Cox*的*Memory Models*系列文章，感觉曾经困扰自己的一些问题得到了解答，曾经进入我脑海中、但始终漂浮不定的概念似乎找到了相连成为完整体系的契机，可谓是茅塞顿开；但是仅仅这样是不够的，我决定将我所学到关于内存模型的知识做个整理，按照我的思路整合为一篇文章，以备日后学习、查阅。

## 起源

内存模型的起源可以追溯至多核心系统的出现，软件界对于多核心 CPU 的多线程的出现有句名言：“免费的午餐结束了”，这反映了多线程为软件开发带来的剧变：硬件性能的提升对软件来说不再是透明的了，软件性能随着硬件性能提升而提升的时代结束了，编码人员必须根据硬件平台的情况开发合适的多线程程序，不然用户就不能享受到多核带来的性能提升。

但是多线程程序的编写并非一帆风顺，早在单线程时代，编译器就会通过调整操作次序来优化寄存器使用，以此减少内存读写，优化程序性能，现代处理器使用的流水线和多发射前端也会在无意间改变操作次序，为了保证在改变操作次序的同时保持程序语义不变，硬件以及编译器和程序之间有个约定：优化不得改变程序的效果，否则优化手段和程序中一定有一个是无效的。

注：此处“无效”的意思是，程序编写者必须遵守语言标准的定义，而编译器也会以此为基准使用优化手段，如果优化改变程序了的行为，那么一定是编码者或编译器没有遵守语言标准（中为不同操作定义的语义）。

但是多线程的出现使这个约定大大地复杂化了，这主要是因为在单线程中有效（指满足约定的，下同）的优化在多线程语境下可能是无效的，简单但典型的例子是：

```c
// Thread 1
x = 1;
done = 1;

 // Thread 2
while(done == 0) { /* loop */ }
print(x);
```

在这个例子中，如果编译器原样翻译代码，处理器也完全按照编译器原样翻译的代码执行，那么预期两个线程都可以正常结束，且打印的值为 1，这是因为第 2 行处的赋值语句在第三行之前，而第三行的副作用被线程二观察到之后，打印语句才会执行；

通过第 6 行的循环，事实上利用 done 的值建立了一个线程之间的**同步**，所以我们预期线程二也可以观察到线程 1 的对 x 的副作用，推导如下：

- 线程 1 中：对 x 的写先于对 done 的写
- 线程 2 中：对 x 的读后于循环
- 在线程 2 的循环中：循环结束后于线程 1 中对 done 的写

但实际情况不是这样的，这是因为编译器和硬件都会对程序进行一定的优化，事实上，只要破坏上述三条中一条，就可能改变程序的行为，如：

- 调换 2、3 行的顺序，破坏第一条；
- 调换 6、7 行的顺序，破坏第二条；
- 将 done 的值读取到寄存器之后一直使用寄存器的值，这样即使内存中 done 的值已经更新了，这更新对线程 2来说可能是不可见的 ，破坏了第三条；

这些优化都可能让打印出来的值变成 0。

这些优化实施的必要性在于：大多数的代码都是单线程的，实施这些优化有利于性能，而对于多线程程序，编译器可能完全不知道一段代码可能涉及多线程，因为代码的并发执行是个运行时（动态）状态，而编译器只能看见编译时（静态）状态，**一个编译时工具是没法预见、控制运行时行为的。**

所以内存模型出现了，内存模型是一种抽象，它反映了有关于内存数据修改时的**可见性**和**一致性**的约定，其中可见性和一致性的具体含义是：

- 可见性：一个线程对内存对象的修改能否被另一个线程看见，上一个例子中就涉及一个可见性的反例，可见性往往代表着一个变量的修改序列在其他的线程上呈现怎样的顺序，即**修改序列**。
- 一致性：不同的线程看见的对一系列内存对象的**总修改序列**和**修改结果**是否一致，其中：
  - 总修改序列：指对一个内存对象进行的若干次修改形成的有序序列，反映了内存对象的修改顺序和值。
  - 修改结果：指在进行了一次或多次修改后内存对象最终的值。

这两方面也是学习内存模型应当关注的要点，通过在这些要点上的不同表现，可以区分不同的内存模型。

当我们提到内存模型时，我们总更倾向于想到编程语言所定义的内存模型，即**软件内存模型**，通过软件内存模型，编译器会抑制可能会破坏多线程程序的优化，同时编译器还会插入合适的指令，使硬件强制同步内存；但是需要知道的，最初的内存模型不涉及高级语言，主要是提供给编写平台相关代码的程序员使用的，使其可以预测并控制硬件在并发代码中的表现，主要包含两个部分：

- 关于硬件行为的承诺
- 硬件定义的同步指令，用于强制内存同步，程序员可以使用这些指令调整硬件的可见性和一致性

这就是**硬件内存模型**

## 历史

事实上，内存模型的理论在多核处理器出现之前就有了，但彼时的理论主要讨论多进程、多处理器的环境，1979 年的论文[How to Make a Multiprocessor Computer That Correctly Executes Multi-process Programs](https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/)给出了关于多处理器系统上**顺序一致（sequential consistency）**的定义，即每个处理器上执行的指令序列都严格地是整个程序指令序列的子序列。而人类历史上第一颗硬件多线程的处理器发布于 2002 年（超线程实现），第一颗多核心处理器发布于 2005 年；而软件线程在 20 世纪 90 年代就已经存在了，历史上第一个民用的多线程操作系统出现在 1993 年，POSIX thread 标准发布于 1995 年，Java 于 1998 年发布其第一代语言内存模型，是第一批尝试定义语言内存模型的编程语言之一；这些时间都远远晚于顺序一致的提出时间。

**无数据竞争-顺序一致（data-race-free sequential consistency）**是现代语言内存模型的基础理论，这一理论发布于 1990 年，见[Weak Ordering – A New Definition](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.5567)。

英特尔于 1997 年开始定义其硬件内存模型，但多有反复，直到十年后的 2008 年，英特尔和 AMD 才正式敲定其内存模型为**存储全序（store total order）**模型；

Java 的第一代内存模型定义于 1998 年，但是有较大缺陷，现行的内存模型定义于 2004 年，于 Java5 引入。

现代 C++的内存模型于 C++11 引入，在此之前 C++没有标准内存模型，其多线程标准主要依靠 POSIX threads 标准及编译器扩展。

## 硬件内存模型

硬件内存模型出现的动机是现代的硬件足够复杂，尽管知道顺序一致也许是最便于开发的模型，但是出于对性能的要求，几乎没有硬件使用顺序一致模型。

### 顺序一致模型

顺序一致模型反映了硬件设计最理想、也是最简单的一种状态，下面这个图是直接从原文抄过来的：

<img src="https://fulllink.s3.bitiful.net/illustrate-sequential-consistency.png" alt="顺序一致模型" style="zoom: 67%;" />

可以看到，在这个模型中，每一个核心都表现出直接和内存交换数据的行为，它们的每一个写入都确保立即写入内存，也就立即为其他核心所见。不过需要注意的是，这个图并不代表真实的硬件设计，一般的来说，如果一种硬件表现出顺序一致的行为，即可认为其使用顺序一致模型，至于其实现我们并不关心。

可以看到，顺序一致模型保证最大程度的一致性：在使用顺序一致模型的机器上，每一个变量都抱着其拥有完全的可见性和一致性，包括整个操作序列的一致性和单个内存对象上的修改序列的一致性。

我将这些保证罗列如下：

- 可见性
- 整个操作序列的一致性
- 单个内存对象的一致性

### STO 模型

x86 处理器使用的内存模型是**存储全序（store total order）**模型，如图：

<img src="https://fulllink.s3.bitiful.net/sto.png" alt="STO模型" style="zoom:67%;" />

它在每个核心上都拥有一个写队列，当核心要修改内存对象的值时，这个修改总是被写入当前核心的写队列，稍后才由写队列写入内存，在写操作从写队列传播到内存之前，其他线程看不见这个修改。这导致了 STO 模型保证不了可见性，如下面的例子：

```c
// Thread 1
x = 1;
r1 = y;

 // Thread 2
y = 1;
r2 = x;
```

若对其进行交错排列，可以发现在顺序一致模型中，是不可能出现`r1`和`r2`同时为 0 这种情况的，这是因为如果其中一个寄存器读到了 0 值，这就意味着该线程上的写操作已经先于另一个线程的写操作发生了，则另一个线程的读操作总是晚于该线程上的写操作，那么至少一个线程可以读到 1，最好的情况下，两个线程都能读到 1。

但问题出在写队列上，提交到写队列，但未提交到内存的写操作对于其他线程是不可见的，所以若在两个线程都进行了写操作但写操作都没有提交到内存时进行读取，那么两个线程就都能读到零。

不过，即便如此，STO 仍然保证一致性，这是因为写缓存是个严格先进先出队列，提交到内存的写入必定保持着其在核心上真实的写入次序；对于其他核心来说，它们也可以观察到这个修改次序。

对于单个内存对象来说，STO 也有保证，这是因为即使有多个核心修改同一个内存对象，一个核心的修改在到达内存时就会立即被所有核心观察到，所以总是可以形成一致的次序。

可见，STO 只保证写顺序（一致性），但不能保证读顺序（可见性），这就是其名字的来源（存储操作对应读操作）。

总结，其保证：

- 整个操作序列的一致性
- 单个内存对象的一致性

它提供的保证更少，可见其比顺序一致模型更弱。

### 宽松模型

ARM、IBM-POWER 处理器上使用的模型是**宽松（relaxed）**模型，这种模型的行为可以描述为：每个核心都有自己的内存副本，读写提交给本核心的内存，不同内存副本上的修改会不定时、不定序的同步给其他核心，图（也是抄过来的）：

<img src="https://fulllink.s3.bitiful.net/relaxed-order.png" alt="relaxed order" style="zoom:67%;" />

这个看起来有点美感的图反映了关于宽松次序的一个事实：宽松次序不保证总次序，也不保证可见性，它只是保证单个内存对象的一致性，而这也是几乎所有硬件模型中能够提供的最弱的保证。

注：原文中有更多有助于理解的例子，但是考虑到本文的性质，这些例子就不再摘抄过来了。

总结，其保证：

- 单个内存对象上的一致性

## 软件内存模型

在前言部分提到，指令顺序同时受硬件和编译器影响，在**硬件内存模型**一节已经说明了硬件设计对指令顺序的影响，并讨论了硬件的内存模型提供的保证，也说到了硬件应当提供同步指令以在适当的时候强制同步内存。

需要说明的是，编译器对指令顺序的保证往往比硬件内存模型都弱，原文中有个编译器调序破坏了单个内存对象上修改序列一致性的例子。

硬件是如此的复杂，即使是上面那样抽象模型都需要时间和精力去分析，对于大多数程序员来说，甚至是这些简化的模型都没必要知道，我们需要一种简单的规则，如果我们编写的程序遵守了这些规则，我们就可以保证我们的程序表现的像在顺序一致的机器上运行一样。

**软件内存模型**用于解决这些问题，它不仅提供了抑制编译器优化的手段，还通过编译器的实现影响着生成的指令的同步行为，其描述了对于一个程序及其对应的指令序列，这指令序列是否符合程序的语义要求。

关于为什么编程语言一定要定义其内存模型呢？如果不定义会怎样？2004 年的论文[Threads Cannot Be Implemented As a Library](https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf)进行了反面论证，从 C 和 C++（2004 年的时候 C++确实没有语言级别的多线程支持）这样没有定义内存模型的语言出发，叙述了为什么编程语言需要关心并发场景下的语义。 

正如在硬件内存模型的定义中包含了**一致性**和**可见性**这两个关键要素一样，当我们提到软件内存模型时，我们也关注几个基本要素，并将其作为划分不同内存模型的基本依据，如其**原子性**、**一致性**和**可见性**（后两者与**同步**紧密相连），通过这些要素，得以区分不同的内存次序。（需要注意的是，这些概念并不是完全互斥的，在一定范围内它们可能有所重合）。

### 顺序一致模型

在最好的情况下，我们所希望的是硬件和编译器忠实地按顺序翻译和执行了每一条指令，并在每一个内存操作完成后都在同步了操作地结果，这就是**顺序一致模型**；但其核心问题在于它太理想了：现代硬件以及足够复杂以至于可以产生多种可观察地行为，单线程上的编译器优化也为软件性能做出了重要贡献，如果失去这些优化恐怕会使多线程程序失去性能优势。

所以尽管顺序一致是如此的明了，但它注定不会成为实际使用的模型。

### 宽松模型的接口：DRF-SC

_Sarita Adve_ 和 *Mark Hill*的成果提出，无法预测的程序行为的来源是数据竞争，若软件实现没有明确说明指令中的写写或读写操作应该保持什么样的顺序，那编译器和硬件的优化手段就可能改变它们的顺序，进而改变语义。

他们提出，软件需要使用**同步模型**消除数据竞争行为，若数据竞争行为消除了，那么程序中所有读写的顺序都是给定的。

这种理论的潜在逻辑是：如果若干个写操作或读、写操作可以随意调整顺序，必然导致其它线程观察到的行为发生变化，为了防止这种变化，需要：

- 使得同步的读写操作带有屏障，防止对指令的调整越过它们
- 将读操作和读操作、读操作和写操作分隔开来，以同步操作作为中介建立它们的顺序

所以，DRF-SC 定义了两类操作：**普通操作**和**同步操作**，其中普通操作可以任意调序，但调序不能穿过同步操作；上文提到，调序所涉及的、可能改变行为的主要是多个线程中对同一变量的写操作或读写操作，所以只要使用同步操作将其分开，为其建立明确的顺序，程序的语义就可以保证，而没有被同步操作隔开的普通操作，硬件和编译器便可以随意调整。

若能通过同步操作将各个线程上的所有数据竞争消除，那这个程序就是顺序一致的。

DRF-SC 代表了一种通用的策略，即：为宽松的底层实现指明顺序，建立了次序较弱的硬件模型和软件实现之间的桥梁，但是 DRF-SC 要求完全消除程序中的竞争，如果做不到，这个模型就不能为行为提供任何保证。论文中，_Sarita Adve_ 和 *Mark Hill*提到的最初的基于DRF理论的模型称为DRF0。

这对于一些语言来说还不错，特别是 C++这类不嫌未定义行为多的语言，更别提 DRF-SC 事实上更有利于优化；但对于 Java 这样更看重明确性的语言来说，DRF-SC 的定义方式未免太不负责任了。

然而，直到今天为止，许多语言内存模型都仍然基于DRF，即使像Java这样对未定义行为容忍度不高的语言，在客观上都无法摆脱存在数据竞争时的未定义行为（完全由硬件实现和调度决定），当然，语言内存模型依然努力地加强语义约束，尽可能的消除反直觉的程序行为；今天，Java和C++的内存模型都强于DRF0。

### happens before

要规范代码语义，就要明确规定在单线程或多线程程序中作用和副作用发生的先后顺序是怎样的，语言利用**先于发生**的概念对进行规范，若说 A 先于 B 发生，则是说在 B 的作用和副作用生效的时候，A 的作用和副作用一定生效了。

在不同的语言中，可以在单线程代码中作为先于发生关系的边界出现的操作定义不一，主要取决于语言对于优化空间和明确语义的取舍。在多线程代码中，作为先于发生的关系的边界的操作一般是带有同步语义的操作，如锁操作或者原子操作。

C++和 Java 所定义的模型都使用 happens before 描述，虽然他们都不是完全使用 happens before 模型——C++定义了严格程度不同的内存次序，并事实上引入了两套原语：全储存顺序+原子操作和弱有序+屏障；Java 则主要是扩展了 happens before 的行为，主要是为了消除thin-air行为对因果一致破坏。

需要注意的是，happens before是一个比较比较模糊的术语，有时候我们会说**happens before次序**，但是另一些时候会说**happens before模型**，前者是C++和Java语言中描述作用次序的概念，后者则在有些场合下作为Java内存模型的名字出现。之所以Java内存模型能称为happens before而C++不能大概是因为Java模型比较强，以至于程序行为可以用8条规则简单地建立happens before次序，相比之下C++的模型弱得多，在非顺序一致模型下，程序行为逐渐变得复杂且难以分析。

### 原子-同步操作

上文提到，在现代的内存模型中，语言定义了带有同步语义的原子操作，通过它们可以在位于多个线程上的、对相同原子变量的多个操作之间同步，再通过原子操作在其所在的线程上形成的**屏障**，代码编写者可以借助原子操作同步非原子操作。所以，虽然很多技术文档使用**原子操作**这个术语，但是显然这些操作叫**原子-同步操作**更妥当些，因为原子变量和操作事实上承担着在多个线程间同步的责任。

## 语言标准内存模型

### Java

#### 历史

Java 是最早的定义内存模型的语言之一，Java 最早的内存模型定义于 1996 年，与其一起定义的还有锁工具及其隐式内存次序要求和 volatile 变量，但那个模型很不完善，有不少错误，而且实践中难以分析、使用，只能算是某种早期尝试。

现在 Java 使用的内存模型于 JSR-133 提出，于 2004 年的 Java5 正式合入 Java 标准，JSR-133 的内存模型基于 happens before 模型定义。

#### 原始内存模型

##### 主内存-工作内存结构

原始内存模型包含了一个对于抽象多线程机器的定义，这个抽象机器描述了 Java 多线程程序的默认行为：机器上的内存由一个主内存和若干工作内存构成，工作内存和线程一一对应，每一个线程都有自己的工作线程，线程不能直接访问主内存，对变量的访问只能先从主内存读到工作内存，修改之后再从工作内存不定时、不定序地写回主内存。

为此，Java 定义了一些基本操作和要求：

- read：从主内存中读取变量值（必须与 load 成对，即不允许出现读了但没有加载到工作内存的情况）
- load：将读取的值加载到工作内存（必须与 read 成对，即不允许出现读了但没有加载到工作内存的情况）
- write：将值写回主内存的变量中（必须与 store 成对，即不允许出现传递给主内存但主内存没有接受的情况）
- store：将工作内存的值传递给主内存（必须与 store 成对，即不允许出现传递给主内存但主内存没有接受的情况）
- assign：修改工作内存中的值（每一个 assign 操作的结果都必须传递给主内存）
- use：将工作内存中的值传递给执行单元
- lock：锁定一个主线程中的变量（线程抢占，一个变量 lock 会使得它在所有工作内存中的值失效）
- unlock：释放一个主线程中的变量（线程抢占，unlock 会使它在工作内存中的值立即同步回主内存）

这些操作都是原子的。

##### volatile 的行为

当使用 volatile 标记一个变量时，这个变量：

- 具有可见性

但是，这个变量：

- 不具备有序性
- 不具备原子性

volatile 变量不能再这个例子中起到同步作用，所以无法消除竞争，所有编译器自然无法在次序方面提供任何保证。

#### JSR-133 模型

某种程度上，JSR-133 定义的内存模型沿用了原始内存模型的定义，包含了一个修改过的外观定义，在这个模型中，原先的 8 个操作被简化为 4 个，新定义和旧定义在行为上是相同的，所以在实现 JVM 时仍然可以使用旧的定义作为参考，而开发人员可以使用新的定义，因为新定义更简单。

##### happens before 模型

happen before 使用两套规则来描述程序行为，这两套规则分别可以适用于单线程上的变量和多线程上的同步变量，分别建立两组顺序明确的修改序列，再进一步通过跨过多个线程的同步变量的次序规定线程上的普通变量的次序，就可以在多个线程的普通变量间建立次序。

这两套规则是：

- 同步顺序：所有同步操作构成一个共同的同步顺序，这个顺序保证可以对所有线程一致地可见；
- 程序顺序：单线程的控制流上的指令构成了程序顺序；

同步顺序和程序顺序共同构成了**happens-before**顺序，这个顺序对于所有线程来说应该是一致的，其中：

- 对同步指令来说，它观察到的值受**同步顺序一致性**影响；
- 对普通指令来说，它观察到的值受**happens-before 顺序一致性**影响；

##### thin-air

Java 的模型在 happens before 的基础上扩展了有关因果一致的内容，这主要是因为 happens before 在一些特定的情况下暴露出因为循环论证导致出现了**凭空出现（thin-air）的值**的问题，这种情况非常反直觉而且严重破坏程序语义，但是在实现上它确实是可行的。

所以 Java 添加了关于**因果一致**的补充规范，以排除这种行为。

#### 基于 happens before 定义的行为

对于 JSR-133 模型的正式定义和证明，在标准文档和一些论文中有更严谨的形式，但是它对开发人员暴露了更易用的接口，主要是描述了对一些行为的规定，这些规定描述了开发人员可以通过 Java 语言中定义的哪些行为使自己的代码满足 happens before 的规定，进而表达出足够明确的语义；

这些行为是：

- 程序次序规则：单线程的程序在控制流前面的指令先于后面的指令；
- 传递性规则：先行关系具有传递性；
- 锁定规则：对同一个锁的释放操作先行于后面的获取操作；
- volatile 读写规则：对同一个 volatile 变量的写先行于后面的读；
- 线程规则：
  - 线程对象的`start()`方法先行于发生于该线程上的每一个动作；
  - 线程中的所有操作都先行于线程的终止检查操作；
  - 对线程的`interrupt()`调用先行于线程中检查中断的动作之前；
- 终结规则：对象的构造函数的结束先行于其`finalize()`方法的调用；

这些行为是非常必要的，其中**程序次序规则**和**终结规则**保证了单线程上的程序行为，而其他的规则保证了跨线程的行为并确保次序可以在不同的线程间传播；可想而知，如果语言没有规定线程的状态的可见性，我们可能连线程处于什么状态都观察不了，更别提从一个线程改变另一个线程的状态。

##### volatile 的行为

在原始内存模型中，volatile 操作提供了**可见性**的保证，但没有提供**一致性**和**原子性**的保证，这被视为是 Java 原始内存模型的一个缺陷，因为 volatile 无法用于线程间的同步，volatile 在原子性方面也表现得过弱，基本上可以认为 volatile 变量除了读写之外得其他操作都保证不了原子性；

因此，在 JSR-133 得模型中，强化了 volatile 的语义，使得其能满足**一致性**要求，所以现在 volatile 可以用于同步（服从**volatile 读写规则**），但是 volatile 仍然没有原子性，在复合操作上可能出现数据竞争。

##### 原子变量

原子变量是 Java 中唯一带有自然原子性保证的类型，还提供了使用硬件特性的 CAS 操作。

### 未完待续...

---
title: 内存模型:读Memory Models (by Russ Cox) 续:C++内存模型
layout: post
date: 2024-03-28
---

## 历史

在C++11之前，C++没有语言级别的内存模型。

事实上，C++的语义被定义在单线程抽象机器上，C++代码编译和执行的假想目标是一台单线程的机器，对于C++11之前的C++标准来说，其行为在多线程机器上是不完备的。当然，C++程序员不可能真的不写多线程程序，彼时的C++多线程程序的语义主要由第三方标准或操作系统实现（pthread、Win32）给出（可以想象，编译至具体硬件平台的操作系统可能会利用硬件级别的专有指令为其线程和原语提供实现），若想写出跨平台的多线程程序，就要寄希望于编译器提供了在多个平台上可用的编译器扩展。

C++11及其之后，C++明确了其内存模型，它基于**RDF0**理论，涉及**Sequenced-before**、**Happens-before**、**Carries dependency**、**Synchronizes with**等重要的概念，以此定义了六种具体的**内存次序**及它们的行为，通过在使用原子操作时指定内存次序，编码者可以控制表达式的**求值**和**副作用**在线程之间的排序。

## 概念和描述

### 修改次序

要描述多线程程序运行的情况，一个常用的方法是描述某个或多个变量的**修改序列**，这个概念假设存在一个记录员，记录了某个或多个变量在一个线程上被修改的次序，如果这个序列在每个线程上都是完全一致的，那就说明在每一个线程上对这些变量进行读取时，它们总是能读到一致的值，即不存在一致性问题；反之，则说明在同一时刻多个线程读取同一个变量时读取到了不一样的值，这种违反一致性的情况不是线程安全的。

当然，实际上这样的一个记录员并不存在，也不会真的有一个记录变量修改顺序的序列存储在内存中的某个地方，修改序列只是一个概念，用来简化分析和沟通。

下面是一个分析修改次序的例子。

假设有以下代码：

```C++
// init
int a=0;
int b=0;

// thread A
a=1;
print b;
    
// thread B
b=1;
print a;
```

假设这段代码运行在x86机器上且编译器不会对代码进行优化，一种可能的修改顺序是thread A将a修改为1但不同步，thread B将b修改为1并同步，此时thread A观察到b被修改为1，然后对a的修改同步至thread B，这之后thread B才能观察到a被修改为1，这个过程对应的修改序列是：

* 在thread A上：a=1，b=1
* 在thread B上：b=1，a=1

可以看到，虽然在全局时间线上我们可以明显地看到对a的修改早于b，但在两个线程修改次序却不一致，受STO传播的影响，在thread B上，对b的修改早于a。
